<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>내 맛집 지도 & 게시판</title>
    <!-- OpenLayers CSS -->
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.6.1/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.6.1/ol.css">

    <!-- Tailwind CSS (간단한 UI 구성용) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/web/static/style.css">
</head>

<body class="font-sans">

    <div class="app-container">
        <!-- 1. 탭 내비게이션 -->
        <nav class="flex items-center justify-between border-b">
            <!-- 왼쪽 탭 버튼 그룹 -->
            <div class="flex">
                <button id="map-tab" class="tab py-3 px-6 text-center text-gray-700 border-b-2 active">
                    맛집 지도
                </button>
                <button id="board-tab" class="tab py-3 px-6 text-center text-gray-500 border-b-2">
                    맛집 게시판
                </button>
            </div>

            <!-- 오른쪽 로그인/회원 상태 -->
            <div id="auth-status" class="px-6 py-3"></div>
        </nav>

        <!-- 로그인/회원가입 모달 -->
        <div id="auth-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
            <div class="bg-white rounded p-6 w-96 relative">
                <button id="close-modal" class="absolute top-2 right-2 text-gray-500 hover:text-gray-700">✖</button>
                <h2 id="modal-title" class="text-xl font-bold mb-4">로그인</h2>

                <input type="text" id="modal-username" placeholder="아이디" class="w-full mb-2 p-2 border rounded" />
                <input type="email" id="modal-email" placeholder="이메일" class="w-full mb-2 p-2 border rounded hidden" />
                <input type="password" id="modal-password" placeholder="비밀번호" class="w-full mb-2 p-2 border rounded" />
                <input type="password" id="modal-confirm-password" placeholder="비밀번호 확인"
                    class="w-full mb-2 p-2 border rounded hidden" />

                <button id="modal-submit"
                    class="w-full py-2 bg-blue-500 text-white rounded hover:bg-blue-600">확인</button>

                <p class="mt-3 text-center">
                    <span id="modal-switch-text">계정이 없으신가요?</span>
                    <button id="modal-switch-btn" class="text-blue-500 underline">회원가입</button>
                </p>
            </div>
        </div>
        <!-- 2. 메인 컨텐츠 영역 -->
        <div class="content-area">
            <!-- 2-1. 지도 컨테이너 -->
            <div id="map-container">
                <div id="map"></div>
            </div>

            <!-- 2-2. 게시판 컨테이너 (처음엔 숨김) -->
            <div id="board-container" class="hidden bg-gray-50 p-4">
                <h2 class="text-xl font-semibold mb-4">맛집 코멘트 목록</h2>
                <div id="board-list" class="space-y-3">
                    <!-- API 데이터로 채워질 영역 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 팝업 오버레이 (위치 변경 없음) -->
    <div id="popup" class="hidden">
        <div id="popup-content"></div>
    </div>


    <!-- 메인 애플리케이션 로직 -->
    <script type="module">
        import * as api from '/web/static/api.js'
        // 'crud' 모듈에서 필요한 함수를 직접 임포트합니다.
        // (예: createBoardItem, attachEventListeners, renderTags 등)
        import { createBoardItem } from '/web/static/crud.js'
        import { setupAuthModal } from '/web/static/authModal.js';

        // 1. OpenLayers 모듈 임포트 간결화 
        const {
            Map: OlMap, View, Feature, Overlay,
            geom: { Point },
            proj: { fromLonLat, toLonLat },
            layer: { Tile: TileLayer, Vector: VectorLayer },
            source: { XYZ, Vector: VectorSource },
            style: { Style, Circle: CircleStyle, Fill, Stroke, Icon }
        } = ol;

        // --- 전역 변수 및 DOM 요소 ---
        const mapTab = document.getElementById('map-tab');
        const boardTab = document.getElementById('board-tab');
        const mapContainer = document.getElementById('map-container');
        const boardContainer = document.getElementById('board-container');
        const boardList = document.getElementById('board-list');

        const popupElement = document.getElementById('popup');
        const popupContent = document.getElementById('popup-content');

        // 상태 변수
        let tags = [];
        let comments = [];
        const commentFeatures = new Map();
        console.log(typeof commentFeatures);
        
        const selectedTags = new Set(); // 태그 선택 상태 관리

        document.addEventListener('DOMContentLoaded', async () => {
            setupAuthModal();

            console.log("here");

            try {
                const loadedTags = await api.getTags();
                if (Array.isArray(loadedTags)) {
                    tags = loadedTags;
                }
            } catch (e) {
                console.error("태그 로드에 실패했습니다:", e);
            }
            await fetchAndDisplayData();
        });

        // 2. VWorld 기본 지도 레이어 (변경 없음)
        const vworldBaseLayer = new TileLayer({
            title: "VWorld 기본지도",
            source: new XYZ({
                url: 'http://xdworld.vworld.kr:8080/2d/Base/201802/{z}/{x}/{y}.png'
            }),
            visible: true,
            zIndex: 1
        });

        // 3. 맛집 마커 스타일 정의 (변경 없음)
        const markerStyle = new Style({
            image: new CircleStyle({
                radius: 8,
                fill: new Fill({ color: 'rgba(255, 0, 0, 0.8)' }),
                stroke: new Stroke({ color: 'rgba(255, 255, 255, 1)', width: 2 }),
            }),
        });

        // 4. 맛집 마커를 담을 벡터 레이어 (변경 없음)
        const vectorSource = new VectorSource();
        const markerLayer = new VectorLayer({
            source: vectorSource,
            style: markerStyle,
            zIndex: 2
        });

        // *NEW: 새로운 마커 (임시 등록 마커)를 위한 별도 레이어/소스
        const newPointSource = new VectorSource();
        const newPointLayer = new VectorLayer({
            source: newPointSource,
            zIndex: 100
        });

        // 5. 팝업 오버레이 설정 (변경 없음)
        const popupOverlay = new Overlay({
            element: popupElement,
        });

        // 6. 지도 초기화 (OlMap을 Map으로 변경)
        const map = new OlMap({
            target: 'map',
            layers: [vworldBaseLayer, markerLayer, newPointLayer], // 임시 마커 레이어 미리 추가
            view: new View({
                center: fromLonLat([127.047748036792411, 37.653194955383256]),
                zoom: 17
            }),
            controls: [],
            overlays: [popupOverlay]
        });

        /**
         * 데이터를 가져와 지도/게시판 UI를 업데이트합니다.
         */
        async function fetchAndDisplayData() {
            // 기존 데이터 초기화 로직
            vectorSource.clear();
            boardList.innerHTML = '';
            commentFeatures.clear();
            closePopup(); // 데이터 갱신 시 혹시 모를 팝업 닫기
            newPointSource.clear(); // 임시 마커도 지우기

            comments = await api.getComments();
            const features = [];

            comments.forEach(comment => {
                // crud.js에 handleBoardItemClick, handleUpdateClick, handleDeleteClick을
                // 이벤트 리스너로 연결하는 로직이 있다고 가정하고 작성합니다.
                const boardItem = createBoardItem(comment);
                boardList.appendChild(boardItem);

                // 게시판 항목 클릭 이벤트 연결
                boardItem.addEventListener('click', () => handleBoardItemClick(comment));

                // CRUD 버튼 이벤트 연결 (crud.js가 아닌 main.js에 정의된 핸들러 사용)
                attachEventListeners(boardItem, comment, handleUpdateClick, handleDeleteClick);

                if (comment.latitude && comment.longitude) {
                    const coords = fromLonLat([comment.longitude, comment.latitude]);

                    const markerFeature = new Feature({
                        geometry: new Point(coords),
                        id: comment.id,
                        text: comment.text,
                        owner_id: comment.owner_id
                    });

                    markerFeature.setId(comment.id);
                    commentFeatures.set(comment.id, markerFeature);
                    features.push(markerFeature);
                }
            });

            vectorSource.addFeatures(features);
            console.log(`맛집 마커 ${features.length}개 / 게시글 ${comments.length}개를 로드했습니다.`);
        }

        /**
         * 지도 팝업을 닫고 임시 마커를 제거합니다.
         */
        function closePopup() {
            popupOverlay.setPosition(undefined);
            popupElement.classList.add('hidden');
            newPointSource.clear(); // 임시 마커 제거
            selectedTags.clear(); // 선택된 태그 초기화
            // 태그 버튼의 'selected' 클래스도 제거해야 하지만, 
            // 팝업이 다시 열릴 때 새롭게 렌더링되므로 여기서는 생략 가능합니다.
        }

        /**
         * 지정된 좌표에 새로운 포인트 마커를 표시합니다.
         */
        function positionNewMarker(coordinate) {
            newPointSource.clear(); // 기존 임시 마커 제거

            const iconFeature = new Feature({
                geometry: new Point(coordinate),
            });

            const iconStyle = new Style({
                image: new Icon({
                    src: '/web/static/images/marker.png',
                    scale: 0.08,
                    anchor: [0.5, 1],
                })
            });

            iconFeature.setStyle(iconStyle);
            newPointSource.addFeature(iconFeature);
        }

        // --- 이벤트 핸들러 (9, 10, 11) ---

        function handleBoardItemClick(comment) {
            if (!comment.latitude || !comment.longitude) {
                console.warn("이 항목은 위치 정보가 없어 지도로 이동할 수 없습니다.");
                return;
            }

            switchToMapView();
            const feature = commentFeatures.get(comment.id);
            if (!feature) return;

            const coordinates = feature.getGeometry().getCoordinates();
            map.getView().animate({
                center: coordinates,
                zoom: 16,
                duration: 1000
            });

            // 팝업 표시 로직 재사용
            displayFeaturePopup(feature, coordinates);
        }

        // 지도 마커 클릭 시 팝업 표시 로직 분리 (재사용성)
        function displayFeaturePopup(feature, coordinates) {
            const text = feature.get('text');
            popupContent.innerHTML = `<strong>맛집 코멘트:</strong><br>${text}`;
            popupOverlay.setPosition(coordinates);
            popupElement.classList.remove('hidden');
        }

        // 10. 수정 버튼 클릭 핸들러 (변경 없음)
        async function handleUpdateClick(comment) {
            const newText = prompt("새로운 댓글 내용을 입력하세요:", comment.text);

            if (!newText || newText.trim() === "") {
                console.log("수정이 취소되었습니다.");
                return;
            }

            try {
                await api.patchComment(comment.id, { text: newText });
                fetchAndDisplayData();
            } catch (error) {
                console.error("댓글 수정에 실패했습니다:", error);
            }
        }

        // 11. 삭제 버튼 클릭 핸들러 (변경 없음)
        async function handleDeleteClick(comment) {
            try {
                await api.removeComment(comment.id);
                fetchAndDisplayData();
            } catch (error) {
                console.error("댓글 삭제에 실패했습니다:", error);
            }
        }

        // --- 12. 지도 클릭 이벤트 (마커 클릭) ---
        map.on('click', function (evt) {
            const feature = map.forEachFeatureAtPixel(evt.pixel, (f) => f);

            if (feature && feature.get('id')) { // 'id' 속성으로 맛집 마커인지 확인
                displayFeaturePopup(feature, feature.getGeometry().getCoordinates());
            } else {
                closePopup(); // 일반 클릭 시 팝업 닫기
            }
        });

        // --- 12. 지도 우클릭 이벤트 (새 맛집 등록) ---
        // --- 12. 지도 우클릭 이벤트 (새 맛집 등록) ---
        map.getViewport().addEventListener('contextmenu', function (evt) {
            evt.preventDefault();
            closePopup();

            const coordinate = map.getEventCoordinate(evt);
            const wgs84 = toLonLat(coordinate);

            positionNewMarker(coordinate); // 임시 마커 표시
            map.renderSync(); // 즉시 렌더링 강제

            map.getView().animate({
                center: coordinate,
                zoom: 18,
                duration: 800
            });

            // 팝업 크기 조절을 위한 클래스 추가 (Tailwind CSS 사용 가정)
            // 실제 팝업 크기는 HTML 또는 CSS에서 조정해야 합니다.
            // 예: popupElement.style.width = '450px';

            // 태그 버튼 HTML 생성 로직
            const tagButtonsHTML = tags.map(tag =>
                `<button class="tag-btn text-sm py-1 px-2 border rounded-full hover:bg-gray-100" data-tag-id="${tag.id}" data-tag-name="${tag.name}">${tag.name}</button>`
            ).join(' ');

            // --- 팝업 내용: 입력 폼과 태그 선택 영역 분리 ---
            popupContent.innerHTML = `
        <div class="flex">
            <div class="w-1/2 pr-3 border-r border-gray-200">
                <h3 class="font-bold mb-2">맛집 정보 입력</h3>
                <input id="title-input" type="text" placeholder="제목"
                    class="w-full mb-3 p-2 border border-gray-300 rounded" />
                <textarea id="comment-input" placeholder="내용" rows="8"
                    class="w-full mb-3 p-2 border border-gray-300 rounded"></textarea>
            </div>

            <div class="w-1/2 pl-3">
                <h3 class="font-bold mb-2">태그 선택</h3>
                <div id="selected-tags-display" class="mb-3 p-2 h-16 border border-blue-400 rounded bg-blue-50 overflow-y-auto">
                    <span class="text-gray-500 italic text-sm">태그를 선택하세요.</span>
                </div>
                <div id="all-tags-container" class="flex flex-wrap gap-2 max-h-40 overflow-y-auto p-1">
                    ${tagButtonsHTML}
                </div>
            </div>
        </div>
        
        <button id="save-comment" 
            class="w-full mt-3 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
            저장
        </button>
    `;

            popupOverlay.setPosition(coordinate);
            popupElement.classList.remove('hidden');

            // --- 새로운 태그 선택 및 표시 로직 ---
            const selectedTagsDisplay = document.getElementById('selected-tags-display');

            function renderSelectedTags() {
                if (selectedTags.size === 0) {
                    selectedTagsDisplay.innerHTML = '<span class="text-gray-500 italic text-sm">태그를 선택하세요.</span>';
                    return;
                }

                const selectedTagNames = Array.from(selectedTags).map(tagId => {
                    const tagObj = tags.find(t => t.id.toString() === tagId);
                    return tagObj ? tagObj.name : '';
                });

                // #이름 형태로 표시
                selectedTagsDisplay.innerHTML = selectedTagNames.map(name =>
                    `<span class="inline-block bg-blue-600 text-white text-xs font-semibold px-2 py-0.5 rounded-full mr-1 mb-1">#${name}</span>`
                ).join('');
            }

            // 초기 렌더링
            renderSelectedTags();

            document.querySelectorAll('.tag-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tagId = btn.dataset.tagId;
                    const tagName = btn.dataset.tagName;

                    // 선택/해제 토글
                    if (selectedTags.has(tagId)) {
                        selectedTags.delete(tagId);
                        btn.classList.remove('bg-sky-500', 'text-white');
                        btn.classList.add('hover:bg-gray-100');
                    } else {
                        selectedTags.add(tagId);
                        btn.classList.add('bg-sky-500', 'text-white');
                        btn.classList.remove('hover:bg-gray-100');
                    }

                    // 선택된 태그 디스플레이 업데이트
                    renderSelectedTags();
                });
            });

            // --- 저장 버튼 ---
            document.getElementById('save-comment').onclick = async function () {
                const title = document.getElementById('title-input').value.trim();
                const text = document.getElementById('comment-input').value.trim();
                if (!text) return alert('댓글을 입력하세요.');

                const data = {
                    text,
                    title,
                    tags: Array.from(selectedTags),
                    latitude: wgs84[1],
                    longitude: wgs84[0],
                };

                try {
                    await api.addComments(data);
                    console.log('저장된 데이터:', data);
                    fetchAndDisplayData();
                    closePopup();
                } catch (error) {
                    alert("댓글 저장에 실패했습니다.");
                    console.error("댓글 저장 실패:", error);
                }
            };
        });

        // --- 13. 탭 전환 로직 (재사용을 위해 분리) ---
        function switchToMapView() {
            mapContainer.classList.remove('hidden');
            boardContainer.classList.add('hidden');
            mapTab.classList.add('active', 'text-gray-700');
            mapTab.classList.remove('text-gray-500');
            boardTab.classList.remove('active', 'text-gray-700');
            boardTab.classList.add('text-gray-500');
            map.updateSize();
        }

        function switchToBoardView() {
            mapContainer.classList.add('hidden');
            boardContainer.classList.remove('hidden');
            boardTab.classList.add('active', 'text-gray-700');
            boardTab.classList.remove('text-gray-500');
            mapTab.classList.remove('active', 'text-gray-700');
            mapTab.classList.add('text-gray-500');
        }

        mapTab.addEventListener('click', switchToMapView);
        boardTab.addEventListener('click', switchToBoardView);

        /**
        * 게시판 항목의 수정/삭제 버튼에 이벤트 리스너를 연결합니다.
        * @param {HTMLElement} item - 게시판 항목 DOM 요소
        * @param {object} comment - 해당 항목의 댓글 데이터
        * @param {function} updateHandler - 수정 버튼 클릭 시 호출될 함수
        * @param {function} deleteHandler - 삭제 버튼 클릭 시 호출될 함수
        */
        function attachEventListeners(item, comment, updateHandler, deleteHandler) {

            // 가정: createBoardItem 함수는 'update-btn'과 'delete-btn' 클래스를 가진
            // 버튼을 item 내부에 생성했다고 가정합니다.

            const updateBtn = item.querySelector('.update-btn');
            const deleteBtn = item.querySelector('.delete-btn');

            // 수정 버튼 리스너 연결
            if (updateBtn) {
                updateBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 항목 클릭(지도 이동) 이벤트 방지
                    updateHandler(comment);
                });
            }

            // 삭제 버튼 리스너 연결
            if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 항목 클릭(지도 이동) 이벤트 방지
                    deleteHandler(comment);
                });
            }
        }

    </script>
</body>

</html>